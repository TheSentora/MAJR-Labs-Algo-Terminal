#pragma version 11
#pragma typetrack false

// algopy.arc4.ARC4Contract.approval_program() -> uint64:
main:
    intcblock 0 1 8
    bytecblock "total_shares" "reward_pool" "shares" "is_initialized" "total_burned" "burn_asset" "admin" 0x151f7c75
    // smart_contracts/liquid_burn_app/contract.py:16-19
    // class LiquidBurnApp(
    //     ARC4Contract,
    //     state_totals=StateTotals(global_uints=5, global_bytes=1, local_uints=1, local_bytes=0),
    // ):
    txn OnCompletion
    !
    assert // OnCompletion must be NoOp
    txn ApplicationID
    bz main_create_NoOp@7
    pushbytess 0xe9892bef 0x0b0f45a1 0xcc82ab99 // method "fund()void", method "burn(uint64)uint64", method "claim()uint64"
    txna ApplicationArgs 0
    match fund burn claim
    err

main_create_NoOp@7:
    // smart_contracts/liquid_burn_app/contract.py:16-19
    // class LiquidBurnApp(
    //     ARC4Contract,
    //     state_totals=StateTotals(global_uints=5, global_bytes=1, local_uints=1, local_bytes=0),
    // ):
    pushbytes 0x86e2e303 // method "initialize(uint64,address)void"
    txna ApplicationArgs 0
    match initialize
    err


// smart_contracts.liquid_burn_app.contract.LiquidBurnApp.initialize[routing]() -> void:
initialize:
    // smart_contracts/liquid_burn_app/contract.py:22
    // @abimethod(create="require")
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    txna ApplicationArgs 2
    dup
    len
    pushint 32 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    // smart_contracts/liquid_burn_app/contract.py:27
    // assert is_initialized.get(UInt64(0)) != UInt64(1), "already initialized"
    intc_0 // 0
    // smart_contracts/liquid_burn_app/contract.py:25
    // is_initialized = GlobalState(UInt64, key="is_initialized")
    bytec_3 // "is_initialized"
    // smart_contracts/liquid_burn_app/contract.py:27
    // assert is_initialized.get(UInt64(0)) != UInt64(1), "already initialized"
    app_global_get_ex
    intc_0 // 0
    cover 2
    select
    intc_1 // 1
    !=
    assert // already initialized
    // smart_contracts/liquid_burn_app/contract.py:28
    // assert Txn.sender == Global.creator_address, "only creator can initialize"
    txn Sender
    global CreatorAddress
    ==
    assert // only creator can initialize
    // smart_contracts/liquid_burn_app/contract.py:30
    // burn_asset = GlobalState(UInt64, key="burn_asset")
    bytec 5 // "burn_asset"
    // smart_contracts/liquid_burn_app/contract.py:36
    // burn_asset.value = asset_id
    uncover 2
    app_global_put
    // smart_contracts/liquid_burn_app/contract.py:31
    // admin_state = GlobalState(Account, key="admin")
    bytec 6 // "admin"
    // smart_contracts/liquid_burn_app/contract.py:37
    // admin_state.value = admin
    swap
    app_global_put
    // smart_contracts/liquid_burn_app/contract.py:25
    // is_initialized = GlobalState(UInt64, key="is_initialized")
    bytec_3 // "is_initialized"
    // smart_contracts/liquid_burn_app/contract.py:38
    // is_initialized.value = UInt64(1)
    intc_1 // 1
    app_global_put
    // smart_contracts/liquid_burn_app/contract.py:32
    // total_burned = GlobalState(UInt64, key="total_burned")
    bytec 4 // "total_burned"
    // smart_contracts/liquid_burn_app/contract.py:40-41
    // # Reset aggregate counters
    // total_burned.value = UInt64(0)
    intc_0 // 0
    app_global_put
    // smart_contracts/liquid_burn_app/contract.py:33
    // total_shares = GlobalState(UInt64, key="total_shares")
    bytec_0 // "total_shares"
    // smart_contracts/liquid_burn_app/contract.py:42
    // total_shares.value = UInt64(0)
    intc_0 // 0
    app_global_put
    // smart_contracts/liquid_burn_app/contract.py:34
    // reward_pool = GlobalState(UInt64, key="reward_pool")
    bytec_1 // "reward_pool"
    // smart_contracts/liquid_burn_app/contract.py:43
    // reward_pool.value = UInt64(0)
    intc_0 // 0
    app_global_put
    // smart_contracts/liquid_burn_app/contract.py:22
    // @abimethod(create="require")
    intc_1 // 1
    return


// smart_contracts.liquid_burn_app.contract.LiquidBurnApp.fund[routing]() -> void:
fund:
    // smart_contracts/liquid_burn_app/contract.py:55
    // admin = admin_state.value
    intc_0 // 0
    // smart_contracts/liquid_burn_app/contract.py:52
    // admin_state = GlobalState(Account, key="admin")
    bytec 6 // "admin"
    // smart_contracts/liquid_burn_app/contract.py:55
    // admin = admin_state.value
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/liquid_burn_app/contract.py:56
    // assert Txn.sender == admin, "only admin can fund rewards"
    txn Sender
    dig 1
    ==
    assert // only admin can fund rewards
    // smart_contracts/liquid_burn_app/contract.py:57
    // assert Txn.group_index != UInt64(0), "fund must follow a payment transfer"
    txn GroupIndex
    assert // fund must follow a payment transfer
    // smart_contracts/liquid_burn_app/contract.py:59
    // payment = gtxn.PaymentTransaction(Txn.group_index - UInt64(1))
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    // smart_contracts/liquid_burn_app/contract.py:61
    // payment.receiver == Global.current_application_address
    dup
    gtxns Receiver
    global CurrentApplicationAddress
    ==
    // smart_contracts/liquid_burn_app/contract.py:60-62
    // assert (
    //     payment.receiver == Global.current_application_address
    // ), "funding payment must target the app account"
    assert // funding payment must target the app account
    // smart_contracts/liquid_burn_app/contract.py:63
    // assert payment.sender == admin, "funding payment must come from admin"
    dup
    gtxns Sender
    uncover 2
    ==
    assert // funding payment must come from admin
    // smart_contracts/liquid_burn_app/contract.py:65
    // reward_pool.value = reward_pool.value + payment.amount
    intc_0 // 0
    // smart_contracts/liquid_burn_app/contract.py:53
    // reward_pool = GlobalState(UInt64, key="reward_pool")
    bytec_1 // "reward_pool"
    // smart_contracts/liquid_burn_app/contract.py:65
    // reward_pool.value = reward_pool.value + payment.amount
    app_global_get_ex
    assert // check GlobalState exists
    swap
    gtxns Amount
    +
    // smart_contracts/liquid_burn_app/contract.py:53
    // reward_pool = GlobalState(UInt64, key="reward_pool")
    bytec_1 // "reward_pool"
    // smart_contracts/liquid_burn_app/contract.py:65
    // reward_pool.value = reward_pool.value + payment.amount
    swap
    app_global_put
    // smart_contracts/liquid_burn_app/contract.py:45
    // @abimethod()
    intc_1 // 1
    return


// smart_contracts.liquid_burn_app.contract.LiquidBurnApp.burn[routing]() -> void:
burn:
    // smart_contracts/liquid_burn_app/contract.py:67
    // @abimethod()
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    // smart_contracts/liquid_burn_app/contract.py:81
    // assert is_initialized.get(UInt64(0)) == UInt64(1), "contract not initialized"
    intc_0 // 0
    // smart_contracts/liquid_burn_app/contract.py:75
    // is_initialized = GlobalState(UInt64, key="is_initialized")
    bytec_3 // "is_initialized"
    // smart_contracts/liquid_burn_app/contract.py:81
    // assert is_initialized.get(UInt64(0)) == UInt64(1), "contract not initialized"
    app_global_get_ex
    intc_0 // 0
    cover 2
    select
    intc_1 // 1
    ==
    assert // contract not initialized
    // smart_contracts/liquid_burn_app/contract.py:82
    // assert amount != UInt64(0), "burn amount must be positive"
    dup
    assert // burn amount must be positive
    // smart_contracts/liquid_burn_app/contract.py:83
    // assert Txn.group_index != UInt64(0), "burn must follow an asset transfer"
    txn GroupIndex
    assert // burn must follow an asset transfer
    // smart_contracts/liquid_burn_app/contract.py:85
    // asset_xfer = gtxn.AssetTransferTransaction(Txn.group_index - UInt64(1))
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    pushint 4 // axfer
    ==
    assert // transaction type is axfer
    // smart_contracts/liquid_burn_app/contract.py:86
    // assert asset_xfer.sender == Txn.sender, "asset sender must match app caller"
    dup
    gtxns Sender
    txn Sender
    ==
    assert // asset sender must match app caller
    // smart_contracts/liquid_burn_app/contract.py:88
    // asset_xfer.asset_receiver == Global.current_application_address
    dup
    gtxns AssetReceiver
    global CurrentApplicationAddress
    ==
    // smart_contracts/liquid_burn_app/contract.py:87-89
    // assert (
    //     asset_xfer.asset_receiver == Global.current_application_address
    // ), "asset must be sent to the app account"
    assert // asset must be sent to the app account
    // smart_contracts/liquid_burn_app/contract.py:91
    // asset_xfer.xfer_asset == Asset(burn_asset.value)
    dup
    gtxns XferAsset
    intc_0 // 0
    // smart_contracts/liquid_burn_app/contract.py:76
    // burn_asset = GlobalState(UInt64, key="burn_asset")
    bytec 5 // "burn_asset"
    // smart_contracts/liquid_burn_app/contract.py:91
    // asset_xfer.xfer_asset == Asset(burn_asset.value)
    app_global_get_ex
    assert // check GlobalState exists
    ==
    // smart_contracts/liquid_burn_app/contract.py:90-92
    // assert (
    //     asset_xfer.xfer_asset == Asset(burn_asset.value)
    // ), "asset id does not match initialized burn asset"
    assert // asset id does not match initialized burn asset
    // smart_contracts/liquid_burn_app/contract.py:93
    // assert asset_xfer.asset_amount == amount, "asset transfer amount mismatch"
    gtxns AssetAmount
    dig 1
    ==
    assert // asset transfer amount mismatch
    // smart_contracts/liquid_burn_app/contract.py:95
    // current_shares = shares_state.get(Txn.sender, UInt64(0))
    txn Sender
    intc_0 // 0
    // smart_contracts/liquid_burn_app/contract.py:79
    // shares_state = LocalState(UInt64, key="shares")
    bytec_2 // "shares"
    // smart_contracts/liquid_burn_app/contract.py:95
    // current_shares = shares_state.get(Txn.sender, UInt64(0))
    app_local_get_ex
    intc_0 // 0
    cover 2
    select
    // smart_contracts/liquid_burn_app/contract.py:96
    // new_balance = current_shares + amount
    dig 1
    +
    // smart_contracts/liquid_burn_app/contract.py:98
    // shares_state[Txn.sender] = new_balance
    txn Sender
    // smart_contracts/liquid_burn_app/contract.py:79
    // shares_state = LocalState(UInt64, key="shares")
    bytec_2 // "shares"
    // smart_contracts/liquid_burn_app/contract.py:98
    // shares_state[Txn.sender] = new_balance
    dig 2
    app_local_put
    // smart_contracts/liquid_burn_app/contract.py:99
    // total_shares.value = total_shares.value + amount
    intc_0 // 0
    // smart_contracts/liquid_burn_app/contract.py:77
    // total_shares = GlobalState(UInt64, key="total_shares")
    bytec_0 // "total_shares"
    // smart_contracts/liquid_burn_app/contract.py:99
    // total_shares.value = total_shares.value + amount
    app_global_get_ex
    assert // check GlobalState exists
    dig 2
    +
    // smart_contracts/liquid_burn_app/contract.py:77
    // total_shares = GlobalState(UInt64, key="total_shares")
    bytec_0 // "total_shares"
    // smart_contracts/liquid_burn_app/contract.py:99
    // total_shares.value = total_shares.value + amount
    swap
    app_global_put
    // smart_contracts/liquid_burn_app/contract.py:100
    // total_burned.value = total_burned.value + amount
    intc_0 // 0
    // smart_contracts/liquid_burn_app/contract.py:78
    // total_burned = GlobalState(UInt64, key="total_burned")
    bytec 4 // "total_burned"
    // smart_contracts/liquid_burn_app/contract.py:100
    // total_burned.value = total_burned.value + amount
    app_global_get_ex
    assert // check GlobalState exists
    uncover 2
    +
    // smart_contracts/liquid_burn_app/contract.py:78
    // total_burned = GlobalState(UInt64, key="total_burned")
    bytec 4 // "total_burned"
    // smart_contracts/liquid_burn_app/contract.py:100
    // total_burned.value = total_burned.value + amount
    swap
    app_global_put
    // smart_contracts/liquid_burn_app/contract.py:67
    // @abimethod()
    itob
    bytec 7 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts.liquid_burn_app.contract.LiquidBurnApp.claim[routing]() -> void:
claim:
    // smart_contracts/liquid_burn_app/contract.py:115
    // shares = shares_state.get(Txn.sender, UInt64(0))
    txn Sender
    intc_0 // 0
    // smart_contracts/liquid_burn_app/contract.py:113
    // shares_state = LocalState(UInt64, key="shares")
    bytec_2 // "shares"
    // smart_contracts/liquid_burn_app/contract.py:115
    // shares = shares_state.get(Txn.sender, UInt64(0))
    app_local_get_ex
    intc_0 // 0
    cover 2
    select
    // smart_contracts/liquid_burn_app/contract.py:116
    // assert shares != UInt64(0), "no shares to claim"
    dup
    assert // no shares to claim
    // smart_contracts/liquid_burn_app/contract.py:117
    // assert total_shares.value != UInt64(0), "no outstanding shares"
    intc_0 // 0
    // smart_contracts/liquid_burn_app/contract.py:112
    // total_shares = GlobalState(UInt64, key="total_shares")
    bytec_0 // "total_shares"
    // smart_contracts/liquid_burn_app/contract.py:117
    // assert total_shares.value != UInt64(0), "no outstanding shares"
    app_global_get_ex
    assert // check GlobalState exists
    dup
    assert // no outstanding shares
    // smart_contracts/liquid_burn_app/contract.py:119
    // payout = (reward_pool.value * shares) // total_shares.value
    intc_0 // 0
    // smart_contracts/liquid_burn_app/contract.py:111
    // reward_pool = GlobalState(UInt64, key="reward_pool")
    bytec_1 // "reward_pool"
    // smart_contracts/liquid_burn_app/contract.py:119
    // payout = (reward_pool.value * shares) // total_shares.value
    app_global_get_ex
    assert // check GlobalState exists
    dup
    dig 3
    *
    uncover 2
    /
    // smart_contracts/liquid_burn_app/contract.py:120
    // assert payout != UInt64(0), "reward pool too small to claim"
    dup
    assert // reward pool too small to claim
    // smart_contracts/liquid_burn_app/contract.py:122
    // reward_pool.value = reward_pool.value - payout
    swap
    dig 1
    -
    // smart_contracts/liquid_burn_app/contract.py:111
    // reward_pool = GlobalState(UInt64, key="reward_pool")
    bytec_1 // "reward_pool"
    // smart_contracts/liquid_burn_app/contract.py:122
    // reward_pool.value = reward_pool.value - payout
    swap
    app_global_put
    // smart_contracts/liquid_burn_app/contract.py:123
    // total_shares.value = total_shares.value - shares
    intc_0 // 0
    // smart_contracts/liquid_burn_app/contract.py:112
    // total_shares = GlobalState(UInt64, key="total_shares")
    bytec_0 // "total_shares"
    // smart_contracts/liquid_burn_app/contract.py:123
    // total_shares.value = total_shares.value - shares
    app_global_get_ex
    assert // check GlobalState exists
    uncover 2
    -
    // smart_contracts/liquid_burn_app/contract.py:112
    // total_shares = GlobalState(UInt64, key="total_shares")
    bytec_0 // "total_shares"
    // smart_contracts/liquid_burn_app/contract.py:123
    // total_shares.value = total_shares.value - shares
    swap
    app_global_put
    // smart_contracts/liquid_burn_app/contract.py:125-126
    // # Clear the caller's share balance.
    // del shares_state[Txn.sender]
    txn Sender
    // smart_contracts/liquid_burn_app/contract.py:113
    // shares_state = LocalState(UInt64, key="shares")
    bytec_2 // "shares"
    // smart_contracts/liquid_burn_app/contract.py:125-126
    // # Clear the caller's share balance.
    // del shares_state[Txn.sender]
    app_local_del
    // smart_contracts/liquid_burn_app/contract.py:128-132
    // itxn.Payment(
    //     amount=payout,
    //     receiver=Txn.sender,
    //     fee=UInt64(0),
    // ).submit()
    itxn_begin
    // smart_contracts/liquid_burn_app/contract.py:130
    // receiver=Txn.sender,
    txn Sender
    itxn_field Receiver
    dup
    itxn_field Amount
    // smart_contracts/liquid_burn_app/contract.py:128
    // itxn.Payment(
    intc_1 // pay
    itxn_field TypeEnum
    // smart_contracts/liquid_burn_app/contract.py:131
    // fee=UInt64(0),
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/liquid_burn_app/contract.py:128-132
    // itxn.Payment(
    //     amount=payout,
    //     receiver=Txn.sender,
    //     fee=UInt64(0),
    // ).submit()
    itxn_submit
    // smart_contracts/liquid_burn_app/contract.py:104
    // @abimethod()
    itob
    bytec 7 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return
